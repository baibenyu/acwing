///*
//本题可以将n视作背包容量,不同的划分方法视作选取物品的方法,物品有1,2,3...,n,每种都有无限个,求划分方法数
//即完全背包求方法数
//步骤:
//	1.状态的表示:f(i,j)表示前i种物品中恰好等于背包容量为j的所有选法,与小于等于不同
//	2.状态的分割:根据每种物品选取的个数进行划分0,1,2,...k
//	3.状态的计算:将所有满足条件的选法相加即为答案
//				即f(i,j) = f(i-1,j)+f(i-1,j-i)+f(i-1,j-2i)...
//	4.优化:完全背包的优化
//	       f(i,j-i) = f(i-1,j-i)+f(i-1,j-2i)+...
//		   即f(i,j) = f(i-1,j)+f(i,j-i)
//	5.再优化:转一维的过程中究竟是顺序还是逆序是由第二维的表达式确定的,
//			现有的转移方程只用到了i-1层的j,i层的j-i,所以顺序遍历即可
//
//*/
//
//
//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 1e3 + 1,mod = 1e9+7;
//
//int n;
//int f[N];
//
//int main()
//{
//	cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
//	cin >> n;
//
//	f[0] = 1;
//	for (int i = 1; i <= n; i++)
//	{
//		for (int j = i; j <= n; j++)
//		{
//			f[j] = (f[j] + f[j - i])%mod;
//		}
//	}
//
//	cout << f[n];
//	return 0;
//}