///*
//贪心解法:当一个上升子序列想尽可能的延长自己,那么应该尽可能地缩短每个元素之间的差距
//步骤:
//	1.维护一个类似于单调递增队列的数据结构
//	2.碰到一个数若该数大于末尾的数,则直接添加在末尾后,
//	  若一个数小于等于末尾,则利用二分查找栈中第一个大于等于该数的数的下标,
//	  然后用该数替换这个找到的数
//	3.最终数组的长度就是最长上升子序列的长度
//	4.解释为什么可以这么做:
//	  (1)当数被添加在末尾,相当于正常扩展上升子序列
//	  (2)当用数去替换数组中第一个大于等于自身的数,是在增加当前数组扩展的可能性,如果一个数能接在一个较大的数后面
//	  那么一定也能接在较小的数后面
//	  (3)有点类似于BFS的多路线
//	  (4)最终的子序列是错误的,但是长度是正确的
//
//*/
//
//
//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 1e5 + 1;
//
//int n;
//int a[N], f[N];
//
//int main()
//{
//	cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
//	cin >> n;
//	for (int i = 0; i < n; i++) cin >> a[i];
//
//	f[0] = a[0];
//	int tail = 0;
//	for (int i = 1; i < n; i++)
//	{
//		if (a[i] > f[tail]) f[++tail] = a[i];
//		else
//		{
//			int l = 0, r = tail;
//			while (l < r)
//			{
//				int mid = l + r >> 1;
//				if (f[mid] >= a[i]) r = mid;
//				else l = mid + 1;
//			}
//			f[r] = a[i];
//		}
//	}
//
//	cout << tail + 1 << '\n';
//
//	return 0;
//}