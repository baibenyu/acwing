///*
//前期准备:
//1.通过观察,瞎猜,蒙,直觉,看题解等手段得知一旦横向摆放的矩形被确定,那么竖向摆放的矩形也被唯一确定
//即可以通过只摆放完横向或竖向的矩形就确定整个大矩形的摆放方式,那么可以推导出大矩形的摆放方法数 = 横向(竖向)矩形的摆放方法数
//
//2.通过画图手段尝试若干种横向摆法后你会发现以下两种情况
//  (1)在1号横向矩形与2号横向矩形或上界(0)或下界(n)构成的限制范围内,行数必须是偶数行,因为竖向矩形是2x1,如果是奇数行就必然剩下一行的空格无法填充,
//  注意此时我们已经确定好了横向矩形的摆法,不能改变了
//  (2)在第i-1列摆放矩形后,第i列就不能摆放矩形,因为横向矩形是横跨两列的,不然会导致中间的小矩形重叠
//
//3.既然是状态压缩DP吧,我们总得压缩点状态你说是吧,根据上述的分析我们好像很在意某一列中横向矩形的摆放方式(在哪几行摆放),
//  所以一列中必然存在两种状态,即有横向矩形与无横向矩形,可以用二进制10来表示有无横向矩形,
//  但是这样只解决了判断一行是否有横向矩形的问题,所以我们可以将二进制数的位数扩展到相应的行数,就可以表示每一行的横向矩形了
//
//4.此时我们DP的f(i,j)这二维都分别确定了下来,i表示列数,j表示的横向矩形在哪几行摆放
//  解决了状态分别代表什么的问题,我们才可以解决第2点中的两个限制.
//  限制1:其实就是j所对应的二进制头尾都加个1,然后判断二进制数中是否有连续的奇数个0,若有说明不合法
//  限制2:枚举,枚举就完事了,因为DP都是根据上一列的状态确定这一列的状态,所以我们枚举相邻两列的放置横向矩形的所有方法,
//  并从中筛选出合法的放置方法,并将前一列对应的状态存储下来
//
//5.万事俱备,终于可以开始DP了
//	5-1:状态的表示:f(i,j)表示第i列使用j这种横向矩形放置方式的所有合法方法
//	5-2:状态的分割:根据j的不同进行分割
//	5-3.状态的计算:综上所诉,f(i,j) += f(i-1,k) k是指第i-1列被存储下来能使得j合法的状态
//
//*/
//
//
//#include <iostream>
//#include <algorithm>
//#include <cstring>
//
//using namespace std;
//
//const int N = 12,M = (1<<11)+1;
//
//int n, m;
//int flag[M], legal[M][M];
//long long f[N][M];
//
//
//int main()
//{
//	cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
//
//	while (cin >> n >> m)
//	{
//		if (n == 0 and m == 0) break;
//		for (int i = 0; i < 1 << n; i++)
//		{
//			int cnt = 0;
//			flag[i] = true;
//			for (int j = 0; j < n; j++)
//			{
//				if ((i >> j) & 1) // 如果第j行放置了横向矩形
//				{
//					if (cnt & 1) // 判断是否合法,奇数就不合法
//					{
//						flag[i] = false; 
//						break;
//					}
//					cnt = 0;
//				}
//				else cnt += 1;
//			}
//			if (cnt & 1) flag[i] = false; // 下边界
//		}
//
//		memset(legal, 0, sizeof(legal));
//		for (int i = 0; i < 1 << n; i++)
//		{
//			int cnt = 1;
//			for (int j = 0; j < 1 << n; j++)
//			{
//				if (flag[i | j] and ((i & j) == 0))
//				{
//					legal[i][cnt++] = j;
//				}
//			}
//			legal[i][0] = cnt;
//		}
//
//		memset(f, 0, sizeof(f));
//		f[0][0] = 1;
//		for (int i = 1; i <= m; i++)
//		{
//			for (int j = 0; j < 1 << n; j++)
//			{
//				for (int k = 1; k < legal[j][0]; k++)
//				{
//					f[i][j] += f[i - 1][legal[j][k]];
//				}
//			}
//		}
//
//		cout << f[m][0]<<'\n';
//	}
//	
//	return 0;
//}