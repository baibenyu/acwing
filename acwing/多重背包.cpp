///*
//多重背包:N种物品,每种物品有si件且不可分割,背包体积为V,物品的体积为vi,价值为wi,求最大可获取的价值数
//与完全背包的区别仅在于,多了一个si限制k的取值范围
//步骤:
//	1.状态的表示:用f(i,j)表示前i种物品中,体积选取不超过j的所有选法中的最大价值数
//	2.状态的分割:选法根据第i种物品选取几个进行分割
//		(1)不选取第i种物品,即选取第i种物品0个,那么最大值就是显然从前i-1个物品中,体积选取不超过j的所有选法中的最大价值数,即f(i-1,j-vi*0)
//		(2)选取第i种物品k个,那么我们只需要知道前i-1个物品中(因为我们已经确定要选取第i个物品了,即前i个,可以变成前i-1个),
//		   体积选取不超过j-vi*k(因为要选取第i个物品,那么倒推回去,前i-1个物品中选取的体积必须小于等于j-vi*k,否则不满足条件)的所有选法中的最大价值数,即f(i-1,j-vi*k)+wi*k
//	3.状态的转移:以上状态的分割包含了所有的选法,所以我们只需要遍历所有选法取价值的最大数即可
//	  for (int k=0;k<=v/Vi and k<=si;k++)
//		f(i,j) = max(f(i,j),f(i-1,j-vi*k)+wi*k)
//	4.优化:
//	  原理:2^0,2^1,2^2,...,2^k,可以组成0-2^(k+1)-1中的任何一个数
//	  所以我们可以把某种物品有si个,表示成logs种新物品,即将si拆成有若干不同的2的幂的形式,剩下不满足的单独成一个
//    这些新物品的体积和价值都是由对应的2的幂次第i种物品组合而成,此时所有物品的个数均为1个,即转化成了01背包
//*/
//
//
//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 25000; // N = 1000*log2000
//
//int n, v, cnt;
//int V[N], W[N], f[N];
//
//
//int main()
//{
//	cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
//
//	cin >> n >> v;
//	int a, b, c;
//	for (int i = 1; i <= n; i++)
//	{
//		cin >> a >> b >> c;
//		int k = 1;
//		while (c >= k)
//		{
//			cnt += 1;
//			V[cnt] = a * k;
//			W[cnt] = b * k;
//			c -= k;
//			k <<= 1;
//		}
//		if (c > 0) // 剩余不可分割,单独成一个新物品
//		{
//			cnt += 1;
//			V[cnt] = a * c;
//			W[cnt] = b * c;
//		}
//	}
//
//
//	for (int i = 1; i <= cnt; i++) // 优化后一维01背包
//		for (int j = v; j >= V[i]; j--)
//			f[j] = max(f[j], f[j - V[i]] + W[i]);
//
//	cout << f[v] << '\n';
//	return 0;
//}
