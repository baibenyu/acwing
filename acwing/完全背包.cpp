///*
//完全背包:N种物品,每种物品有无数件且不可分割,背包体积为V,物品的体积为vi,价值为wi,求最大可获取的价值数
//步骤:
//	1.状态的表示:用f(i,j)表示前i种物品中,体积选取不超过j的所有选法中的最大价值数
//	2.状态的分割:选法根据第i种物品选取几个进行分割
//		(1)不选取第i种物品,即选取第i种物品0个,那么最大值就是显然从前i-1个物品中,体积选取不超过j的所有选法中的最大价值数,即f(i-1,j-vi*0)
//		(2)选取第i种物品k个,那么我们只需要知道前i-1个物品中(因为我们已经确定要选取第i个物品了,即前i个,可以变成前i-1个),
//		   体积选取不超过j-vi*k(因为要选取第i个物品,那么倒推回去,前i-1个物品中选取的体积必须小于等于j-vi*k,否则不满足条件)的所有选法中的最大价值数,即f(i-1,j-vi*k)+wi*k
//	3.状态的转移:以上状态的分割包含了所有的选法,所以我们只需要遍历所有选法取价值的最大数即可
//	  for (int k=0;k<=v/vi;k++) 
//		f(i,j) = max(f(i,j),f(i-1,j-vi*k)+wi*k)
//	4.优化:f(i,j-vi) = max(f(i-1,j-vi),f(i-1,j-vi*2)+wi,...)
//         f(i,j) = max(f(i-1,j),f(i-1,j-vi)+wi,f(i-1,j-vi*2)+2*wi,...)
//		   f(i,j) 每一项都比f{i,j-vi)多wi,若求f(i,j)最大,即求f(i,j-vi)+wi
//		   f(i,j-vi)是比f(i,j)少一项的,因为背包体积小
//  5.再优化:基于01背包的优化方法,我们也可以将完全背包的f数组降维,但是我们此时的f(j)是使用f(i)层的f(j-vi)来更新的,所以无需逆序遍历.
//	
//*/
//
//
//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 1e3 + 1;
//
//int n, v;
//int V[N], W[N], f[N][N];
//
//
//int main()
//{
//	cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
//
//	cin >> n >> v;
//	for (int i = 1; i <= n; i++) cin >> V[i] >> W[i];
//
//	for (int i = 1; i <= n; i++)
//	{
//		for (int j = 1; j <= v; j++)
//		{
//			f[i][j] = f[i - 1][j];
//			if (j >= V[i]) f[i][j] = max(f[i][j], f[i][j - V[i]] + W[i]);
//		}
//	}
//
//	cout << f[n][v] << '\n';
//	return 0;
//}
