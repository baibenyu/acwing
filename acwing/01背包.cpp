///*
//01背包:N种物品,每种物品只有一件且不可分割,背包体积为V,物品的体积为vi,价值为wi,求最大可获取的价值数
//所有背包优化成一维都是基于数据更新的先后顺序的,让i-1行与第i行的数据共同存在f数组里,具体是顺序遍历还是逆序遍历是由二维的状态转移决定的
//步骤:
//	1.状态的表示:用f(i,j)表示前i个物品中,体积选取不超过j的所有选法中的最大价值
//	2.状态的分割:选法分成选取第i个物品,以及不选取第i个物品
//		(1)不选取第i个物品,那么最大值就是显然从前i-1个物品中,体积选取不超过j的所有选法中的最大价值,即f(i-1,j)
//		(2)选取第i个物品,那么我们只需要知道前i-1个物品中(因为我们已经确定要选取第i个物品了,即前i个,可以变成前i-1个),
//		   体积选取不超过j-vi(因为要选取第i个物品,那么倒推回去,前i-1个物品中选取的体积必须小于等于j-vi,否则不满足条件)的所有选法中的最大价值,即f(i-1,j-vi)+wi
//	3.状态的转移:以上状态的分割包含了所有的选法,所以我们只需要在两种选法之间取价值的最大数即可
//	  即f(i,j) = max(f(i-1,j),f(i-1,j-vi)+wi)
//  4.优化:注意到在遍历过程中实际上只使用了f(i-1)以及f(i)这两个相邻数组,所以可以降维,将所有数据都存在f(i)中,转而用遍历顺序的不同来区分是f(i-1)的数据还是f(i)的数据
//    如果从顺序遍历背包体积,那么轮到大于等于vi的j时,此时f(i)是使用了f(i-vi)已经更新过的同属于f(i)的数据.但我们需要的是f(i-1)层的数据,
//    所以需要逆序遍历背包体积.
//    for (int j=v;j>=vi;j--) f(j) = max(f(j),f(j-vi)+wi)
//*/
//
//
//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 1e3 + 1;
//
//int n, v;
//int V[N], W[N], f[N][N];
//
//
//int main()
//{
//	cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);
//
//	cin >> n >> v;
//	for (int i = 1; i <= n; i++) cin >> V[i] >> W[i];
//
//	for (int i = 1; i <= n; i++)
//	{
//		for (int j = 1; j <= v; j++)
//		{
//			f[i][j] = f[i - 1][j];
//			if (j >= V[i]) f[i][j] = max(f[i][j], f[i - 1][j - V[i]] + W[i]);
//		}
//	}
//
//	cout << f[n][v] << '\n';
//	return 0;
//}